<?php
/**
 * @file
 * A description of what your module does.
 */


/**
 *  Implements hook_menu().
 */
function course_info_menu() {
    $items = array();
    $items['admin/config/services/course_info'] = array(
        'title' => t('OILS Course Information Settings'),
        'description' => 'Configure URL of \'UNM Open Data\' for importing into Drupal.',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('course_info_admin_form'),
        'access arguments' => array('administer OILS course info settings'),
        'file' => 'course_info.admin_form.inc',
        'type' => MENU_NORMAL_ITEM,
    );
    $items['admin/config/services/course_info/settings'] = array(
        'title' => t('Settings'),
        'type' => MENU_DEFAULT_LOCAL_TASK,
        'weight' => 0,
    );

    return $items;
}

/**
 *  Implements hook_permission().
 */
function course_info_permission() {
    return array(
        'administer course info settings' => array(
            'title' => t('Administer OILS course info configuration'),
            'description' => t('Perform administration tasks on OILS course info module.'),
        ),
    );
}

/**
 * Grab unm courses information xml file.
 * Parse, and place OILS relevent info into DB.
 *
 * @return void
 */
function load_course_info_from_web() {

    $destination = 'public://';
    // Grab URL of course data file
    $url_result = db_query('SELECT * FROM courses_info_url');
    $msg = '';
    // There should only be one...
    $reader = new XMLReader();
    foreach ($url_result as $row) {
        $file = system_retrieve_file($row->url, $destination, TRUE);
        if($file) {
            $reader->open($file->uri);
            while($reader->read()){
                if ($reader->name == 'college' && $reader->getAttribute('code') == 'LL') {
                    break;
                }
            }
            $data = new SimpleXMLElement($reader->readOuterXml());
            $data = drupal_json_decode(drupal_json_encode($data));
            //dpm($data);
        }
        else {
            $msg = "Unable to retrieve " . $row->url . ", course nodes will not be updated.";
        }
        buildCourseEntities($data, 'department');


    }


}


/*
 * General function to start entity creation process.
 * This determines whether entity already exists and shunts it
 * to either be created or updated.
 *
 * @param $data - Subset of XML data to be processed into entity
 * @param $type - The type of entity to be created (department, course, section, etc...)
 *
 * @return node_id
 */
function buildCourseEntities($data, $type) {

    //dpm($type);
    //dpm($data);

    /*
     * How to check if there are multiples of the object you are inserting:
     * e.x. - if department['@attributes'] doesnt exist, then you probably
     * have something like department[0]['@attributes']
     *
     * Two ideas to check:
     * 1) If children of department are named as ints
     * 2) If @attributes doesnt exist as a direct child.
     */


    /*
     * Start moving through data, our assumed top level is College
     */
    $existing_entity_list = db_query('select nid, title from {node} n where n.type = :type', array(':type' => $type));
    foreach ($existing_entity_list as $existing_entity) {
        $entity_list["$existing_entity->title"] = $existing_entity->nid;
    }

    $title_key = "";
    switch($type) {
        case 'department':
            $title_key = 'code';
            break;
        case 'subject':
            $title_key = 'code';
            //code
            break;
        case 'course':
            $title_key = 'number';
            //code
            break;
        case 'section':
            $title_key = 'crn';
            //code
            break;
        case 'instructor':
            $title_key = 'title';
            //code
            break;
    }

    // Sloppy test to see if there is more than one entity of this type
    if(testNewEntityPlurality($data[$type])){
        dpm('plural');
        foreach($data[$type] as $new_entity){
            $new_entity_title = $new_entity['@attributes'][$title_key];
            if (array_key_exists($new_entity_title, $entity_list)){
                dpm('update');
                dpm($new_entity_title);
                return updateCourseInfoEntity($new_entity, $type);
            }
            else {
                dpm('create');
                return createNewCourseInfoEntity($new_entity, $type);
            }
        }
    }
    else {
        dpm('not plural');
        $new_entity = $data[$type];
        $new_entity_title = $new_entity['@attributes'][$title_key];
        dpm($new_entity_title);
        if (array_key_exists($new_entity_title, $entity_list)){
            dpm('exists');
            return updateCourseInfoEntity($new_entity, $type);
        }
        else {
            dpm('doesnt exist');
            return createNewCourseInfoEntity($new_entity, $type);
        }
    }

}


function testNewEntityPlurality($data){
    if(array_key_exists(0, $data)){
        return TRUE;
    }
    else {
        return FALSE;
    }
}



/*
 * This creates a new node of type $type with data in $data
 *
 * @param $data - subset of XML data, hopefully beginning at a value of type $type.
 * @param $type - type of entity to create
 *
 * @return node_id
 */
function createNewCourseInfoEntity($data, $type) {
    dpm($type);
    dpm($data);
    global $user;
    switch ($type) {
        case 'department':
            $attributes = $data['@attributes'];
            // Need to test for subject plurality here
            if (testNewEntityPlurality($data['subject'])){
                // Hacky, but makes the foreach work no matter what.
                $subjects = $data['subject'];
            }
            else {
                $subjects[0] = $data['subject'];
            }
            $values = array(
                'type' => 'department',
                'uid' => $user->uid,
                'status' => 1,
                'comment' => 0,
                'promote' => 0,
            );
            $entity = entity_create('node', $values);
            $wrapper = entity_metadata_wrapper('node', $entity);

            // Set all values
            if (isset($attributes["code"]) && !empty($attributes["code"])) {
                $wrapper->title->set($attributes["code"]);
            }
            if (isset($attributes["name"]) && !empty($attributes["name"])) {
                $wrapper->field_name->set($attributes["name"]);
            }
            // Now we have to set an entity reference for every associated subject.
            foreach ($subjects as $subject) {
                // Create or Update individual Subject node (and create necessary nodes recursively on downwards)
                // Then... create the entity reference for each newly created node as they are finished creating.
                // Maybe I should return an NID ...
                $subject_nid = buildCourseEntities($data, 'subject'); // <---------------------------------------------------------------------
                $entity->field_subject[$entity->language][]['target_id'] = $subject_nid;
            }
            // The End - Save It
            $wrapper->save();
            break;

        case 'subject':
            $attributes = $data['@attributes'];
            if (testNewEntityPlurality($data['course'])){
                $courses = $data['course'];
            }
            else {
                $courses[0] = $data['course'];
            }
            $values = array(
                'type' => 'subject',
                'uid' => $user->uid,
                'status' => 1,
                'comment' => 0,
                'promote' => 0,
            );
            $entity = entity_create('node', $values);
            $wrapper = entity_metadata_wrapper('node', $entity);

            // Set all values
            if(isset($attributes["code"]) && !empty($attributes["code"])) {
                $wrapper->title->set($attributes["code"]);
            }
            if (isset($attributes["name"]) && !empty($attributes["name"])) {
                $wrapper->field_name->set($attributes["name"]);
            }

            foreach ($courses as $course){
                $course_nid = buildCourseEntities($course, 'course');
                $entity->field_course[$entity->language][]['target_id'] = $course_nid;
            }

            $wrapper->save();
            break;

        case 'course':
            $attributes = $data['@attributes'];
            if(testNewEntityPlurality($data['section'])){
                $sections = $data['section'];
            }
            else {
                $sections[0] = $data['section'];
            }
            $values = array(
                'type' => 'course',
                'uid' => $user->uid,
                'status' => 1,
                'comment' => 0,
                'promote' => 0,
            );
            $entity = entity_create('node', $values);
            $wrapper = entity_metadata_wrapper('node', $entity);

            // Set all values
            if(isset($attributes["number"]) && !empty($attributes["number"])) {
                $wrapper->title->set($attributes["number"]);
            }
            if(isset($attributes["title"]) && !empty($attributes["title"])) {
                $wrapper->field_title->set($attributes["title"]);
            }
            if(isset($data["catalog-description"]) && !empty($data["catalog-description"])) {
                $wrapper->body->value->set($data["catalog-description"]);
            }

            $wrapper->save();
            break;

        case 'section':
            //code
            break;

        case 'instructor':
            //code
            break;
    }
    return $wrapper->nid->raw();

}

/*
 * This updates an existing node of type $type with data in $data
 *
 * @param $data - subset of XML data, hopefully beginning at a value of type $type.
 * @param $type - type of entity to create
 *
 * @return node_id
 */
function updateCourseInfoEntity($data, $type) {
    switch ($type) {
        case 'department':
            //code
            break;
        case 'subject':
            //code
            break;
        case 'course':
            //code
            break;
        case 'section':
            //code
            break;
        case 'instructor':
            //code
            break;
    }
}
